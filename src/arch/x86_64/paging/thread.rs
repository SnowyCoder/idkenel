use core::ptr;

use x86_64::{
    registers::model_specific::FsBase,
    structures::paging::{FrameAllocator, Mapper, Page, PageTableFlags, Size4KiB},
    VirtAddr,
};

use crate::{
    allocator::HeapFrameAllocator,
    arch::x86_64::consts::{KERNEL_THREAD_DATA_START, KERNEL_THREAD_STORAGE_SIZE},
};

use super::get_page_table;

/*pub fn create_lvl4_page_table<T: FrameAllocator<Size4KiB>>(offset: VirtAddr, frame_allocator: &mut T) -> OffsetPageTable {
    let frame = frame_allocator.allocate_frame().expect("Cannot allocate frame");
    let addr = offset + frame.start_address().as_u64();
    let ptr = addr.as_mut_ptr();
    let level_4_table = unsafe {
        *ptr = PageTable::new();
        &mut *ptr
    };

    unsafe { OffsetPageTable::new(level_4_table, phys_offset) }
}*/

fn allocate_map_range(
    addr: VirtAddr,
    size: u64,
    flags: PageTableFlags,
    frame_allocator: &mut HeapFrameAllocator,
) {
    let mut ptable = get_page_table();

    let first_page = Page::<Size4KiB>::containing_address(addr);
    let last_page = Page::<Size4KiB>::containing_address(addr + size - 1usize);

    for page in Page::range_inclusive(first_page, last_page) {
        let frame = frame_allocator
            .allocate_frame()
            .expect("Error: out of memory");
        unsafe {
            ptable
                .map_to(page, frame, flags, frame_allocator)
                .expect("Error mapping map_range")
                .flush();
        }
    }
}

extern "C" {
    // These are symbols generated by the linker, it's as if these are normal static variables
    // but placed exactly where the linker was while writing them.
    // so __tdata_start will be the first byte of the .tdata segment (and its address will be the
    // exact address of the first byte of tdata)
    static mut __tdata_start: u8;
    static mut __tdata_end: u8;
    static mut __tbss_start: u8;
    static mut __tbss_end: u8;
}

pub unsafe fn setup_thread_data(cpu: u64, frame_allocator: &mut HeapFrameAllocator) {
    let start_addr =
        VirtAddr::new(KERNEL_THREAD_DATA_START + (cpu as u64) * KERNEL_THREAD_STORAGE_SIZE);
    allocate_map_range(
        start_addr,
        KERNEL_THREAD_STORAGE_SIZE,
        PageTableFlags::PRESENT | PageTableFlags::WRITABLE,
        frame_allocator,
    );

    let tdata_len = (&__tdata_end as *const _ as usize) - (&__tdata_start as *const _ as usize);
    let tbss_len = (&__tbss_end as *const _ as usize) - (&__tbss_start as *const _ as usize);
    let end = start_addr + tdata_len + tbss_len;

    // Can we check this at compile time? I'm not really sure, at leas not in "this" code.
    // we could move this into a test or into a build.rs code, but tdata and tbss are generated by the linker so
    // they are generated after any of the const code runs (so no compile-time operations are possible here)
    if tdata_len + tbss_len > KERNEL_THREAD_STORAGE_SIZE as usize {
        panic!(
            "Cannot fit tdata + tbss into the allocated length ({:x} + {:x} > {:x}), allocate more",
            tdata_len, tbss_len, KERNEL_THREAD_STORAGE_SIZE
        );
    }

    //println!("TDATA {:x} - {:x}", start_addr.as_u64() as usize, start_addr.as_u64() as usize + tdata_len);
    //println!("TBSS  {:x} - {:x}", start_addr.as_u64() as usize + tdata_len, start_addr.as_u64() as usize + tdata_len + tbss_len);
    ptr::copy_nonoverlapping::<u8>(&__tdata_start, start_addr.as_mut_ptr(), tdata_len);
    ptr::write_bytes::<u8>(
        start_addr.as_mut_ptr::<u8>().offset(tdata_len as isize),
        0,
        tbss_len,
    );

    let data_offset = end - core::mem::size_of::<usize>();

    *data_offset.as_mut_ptr() = end;

    // TODO: USE GS
    // Load the thread data pointer directly into the GS register
    // when you access a thread local variable the kernel uses GS
    // to know where that data is actually stored
    // there's also another space for the userspace GS register, when switching from
    // userspace to kernelspace or back those are swapped (with Gs::swap())

    // Well, ideally we should use GS since there the swapgs instruction, but the compilers
    // we are using always target fs because this is what linux x86-64 does, and I don't want to
    // patch the compilers (Redox way) or write custom-made macros to access thread_local variables
    // (fuchsia, linux, and many other kernels).
    //GsBase::write(data_offset);
    FsBase::write(data_offset);
}
